python manage.py shell

from oids.models import Unit, TerritorialManagement
print(f"Кількість ТУ в базі: {TerritorialManagement.objects.count()}")
print(f"Кількість ВЧ в базі: {Unit.objects.count()}")



Етап 4: Перевірка та валідація
Після запуску скрипту обов'язково перевірте результат.

Кількісна перевірка:

Порахуйте кількість рядків у вашому CSV файлі.

Зайдіть у django shell (python manage.py shell) і перевірте кількість об'єктів у базі:

Python

from oids.models import Unit, TerritorialManagement
print(f"Кількість ТУ в базі: {TerritorialManagement.objects.count()}")
print(f"Кількість ВЧ в базі: {Unit.objects.count()}")
Чи збігаються числа (з урахуванням пропущених рядків, про які скрипт виводив попередження)?

Якісна перевірка:

Зайдіть в адмін-панель Django.

Відкрийте кілька щойно створених військових частин.

Перевірте, чи правильно заповнені всі поля.

Найголовніше: перевірте, чи правильно встановлено зв'язок ForeignKey (чи прив'язана частина до правильного територіального управління).

Поради та найкращі практики
Порядок імпорту є критичним: Завжди імпортуйте "батьківські" моделі перед "дочірніми" (TerritorialManagement перед Unit, Unit перед OID, OID і WorkRequest перед WorkRequestItem і т.д.).

Обробка помилок: Обгортайте логіку пошуку батьківських об'єктів у try...except Model.DoesNotExist, щоб ваш скрипт не "впав" на першому ж рядку з некоректним зв'язком.

Великі обсяги даних: Якщо у вас десятки тисяч рядків, для оптимізації можна використовувати Model.objects.bulk_create(), але цей метод не викликає save() для кожного об'єкта, тому логіка, яку ми писали в save(), не спрацює. Для початкового завантаження get_or_create є надійнішим.

ManyToMany поля: Для заповнення ManyToManyField (як unit_groups у моделі Unit) вам потрібно спочатку створити об'єкт (unit, created = ...), а потім додати зв'язки: unit.unit_groups.add(group_instance).

Цей процес вимагає уваги, але такий підхід дає вам повний контроль і гарантує, що ваші реальні дані будуть перенесені до нової системи коректно.